{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7527dece-2e83-4fc3-8101-af16b773400a",
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'yfinance'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[2], line 7\u001b[0m\n\u001b[0;32m      5\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mscipy\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mstats\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m \u001b[38;5;21;01mstats\u001b[39;00m\n\u001b[0;32m      6\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mscipy\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01moptimize\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m minimize\n\u001b[1;32m----> 7\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01myfinance\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m \u001b[38;5;21;01myf\u001b[39;00m\n\u001b[0;32m      8\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mstatsmodels\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mtsa\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mstattools\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m adfuller\n\u001b[0;32m      9\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mstatsmodels\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mgraphics\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mtsaplots\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m plot_acf, plot_pacf\n",
      "\u001b[1;31mModuleNotFoundError\u001b[0m: No module named 'yfinance'"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import scipy.stats as stats\n",
    "from scipy.optimize import minimize\n",
    "import yfinance as yf\n",
    "from statsmodels.tsa.stattools import adfuller\n",
    "from statsmodels.graphics.tsaplots import plot_acf, plot_pacf\n",
    "import statsmodels.api as sm\n",
    "from sklearn.metrics import mean_squared_error, mean_absolute_error, mean_absolute_percentage_error\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# Set plotting style\n",
    "plt.style.use('seaborn-v0_8-darkgrid')\n",
    "np.random.seed(42)\n",
    "\n",
    "def fetch_stock_data(ticker='AAPL', period='5y'):\n",
    "    \"\"\"\n",
    "    Fetch stock data using yfinance\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    ticker : str\n",
    "        Stock ticker symbol\n",
    "    period : str\n",
    "        Period to fetch data for (e.g., '1y', '5y')\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    DataFrame with stock price data\n",
    "    \"\"\"\n",
    "    print(f\"Fetching {ticker} stock data for the past {period}...\")\n",
    "    \n",
    "    try:\n",
    "        stock = yf.Ticker(ticker)\n",
    "        data = stock.history(period=period)\n",
    "        \n",
    "        # Check if data was fetched successfully\n",
    "        if data.empty:\n",
    "            raise ValueError(f\"No data found for {ticker}\")\n",
    "            \n",
    "        print(f\"Successfully fetched {len(data)} days of data\")\n",
    "        return data\n",
    "    except Exception as e:\n",
    "        print(f\"Error fetching data: {e}\")\n",
    "        # Generate synthetic data if fetch fails\n",
    "        return generate_synthetic_stock_data(n_samples=1000)\n",
    "\n",
    "def generate_synthetic_stock_data(n_samples=1000, initial_price=100, \n",
    "                               drift=0.0002, volatility=0.01):\n",
    "    \"\"\"\n",
    "    Generate synthetic stock data for testing\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    n_samples : int\n",
    "        Number of days to generate\n",
    "    initial_price : float\n",
    "        Starting stock price\n",
    "    drift : float\n",
    "        Daily drift parameter (mean return)\n",
    "    volatility : float\n",
    "        Daily volatility parameter\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    DataFrame with synthetic stock price data\n",
    "    \"\"\"\n",
    "    print(\"Generating synthetic stock data...\")\n",
    "    \n",
    "    # Generate dates\n",
    "    dates = pd.date_range(end=pd.Timestamp.today(), periods=n_samples)\n",
    "    \n",
    "    # Generate log returns with normal distribution\n",
    "    log_returns = np.random.normal(drift, volatility, n_samples)\n",
    "    \n",
    "    # Calculate price series\n",
    "    prices = [initial_price]\n",
    "    for ret in log_returns:\n",
    "        prices.append(prices[-1] * np.exp(ret))\n",
    "    prices = prices[1:]  # Remove the initial price\n",
    "    \n",
    "    # Create DataFrame\n",
    "    data = pd.DataFrame({\n",
    "        'Open': prices,\n",
    "        'High': [p * (1 + np.random.uniform(0, 0.02)) for p in prices],\n",
    "        'Low': [p * (1 - np.random.uniform(0, 0.02)) for p in prices],\n",
    "        'Close': [p * (1 + np.random.normal(0, 0.005)) for p in prices],\n",
    "        'Volume': [int(np.random.uniform(1000000, 10000000)) for _ in prices]\n",
    "    }, index=dates)\n",
    "    \n",
    "    print(f\"Generated {len(data)} days of synthetic data\")\n",
    "    return data\n",
    "\n",
    "def explore_data(data):\n",
    "    \"\"\"\n",
    "    Perform exploratory data analysis on stock data\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    data : DataFrame\n",
    "        Stock price data\n",
    "    \"\"\"\n",
    "    print(\"\\n=== Exploratory Data Analysis ===\")\n",
    "    \n",
    "    # Basic statistics\n",
    "    print(\"\\nBasic Statistics:\")\n",
    "    print(data[['Open', 'High', 'Low', 'Close', 'Volume']].describe())\n",
    "    \n",
    "    # Calculate returns\n",
    "    data['Returns'] = data['Close'].pct_change() * 100\n",
    "    data['Log_Returns'] = np.log(data['Close'] / data['Close'].shift(1)) * 100\n",
    "    \n",
    "    # Plot price series\n",
    "    plt.figure(figsize=(14, 6))\n",
    "    plt.plot(data.index, data['Close'])\n",
    "    plt.title('Stock Price (Close)')\n",
    "    plt.xlabel('Date')\n",
    "    plt.ylabel('Price ($)')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Plot returns\n",
    "    plt.figure(figsize=(14, 10))\n",
    "    \n",
    "    plt.subplot(2, 1, 1)\n",
    "    plt.plot(data.index[1:], data['Returns'][1:])\n",
    "    plt.title('Daily Returns (%)')\n",
    "    plt.xlabel('Date')\n",
    "    plt.ylabel('Returns (%)')\n",
    "    \n",
    "    plt.subplot(2, 1, 2)\n",
    "    plt.plot(data.index[1:], data['Log_Returns'][1:])\n",
    "    plt.title('Daily Log Returns (%)')\n",
    "    plt.xlabel('Date')\n",
    "    plt.ylabel('Log Returns (%)')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Distribution of returns\n",
    "    plt.figure(figsize=(14, 6))\n",
    "    \n",
    "    plt.subplot(1, 2, 1)\n",
    "    sns.histplot(data['Returns'].dropna(), kde=True)\n",
    "    plt.title('Distribution of Returns')\n",
    "    plt.xlabel('Returns (%)')\n",
    "    \n",
    "    plt.subplot(1, 2, 2)\n",
    "    sns.histplot(data['Log_Returns'].dropna(), kde=True)\n",
    "    plt.title('Distribution of Log Returns')\n",
    "    plt.xlabel('Log Returns (%)')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # QQ plot for returns\n",
    "    plt.figure(figsize=(14, 6))\n",
    "    \n",
    "    plt.subplot(1, 2, 1)\n",
    "    stats.probplot(data['Returns'].dropna(), dist=\"norm\", plot=plt)\n",
    "    plt.title('Q-Q Plot of Returns')\n",
    "    \n",
    "    plt.subplot(1, 2, 2)\n",
    "    stats.probplot(data['Log_Returns'].dropna(), dist=\"norm\", plot=plt)\n",
    "    plt.title('Q-Q Plot of Log Returns')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    return data\n",
    "\n",
    "def analyze_stationarity(data):\n",
    "    \"\"\"\n",
    "    Test for stationarity and analyze autocorrelation\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    data : DataFrame\n",
    "        Stock price data with returns\n",
    "    \n",
    "    Returns:\n",
    "    --------\n",
    "    is_stationary : bool\n",
    "        Whether log returns are stationary\n",
    "    \"\"\"\n",
    "    print(\"\\n=== Stationarity Analysis ===\")\n",
    "    \n",
    "    # Perform Augmented Dickey-Fuller test\n",
    "    print(\"\\nAugmented Dickey-Fuller Test for Stationarity:\")\n",
    "    \n",
    "    # Test on prices\n",
    "    price_result = adfuller(data['Close'].dropna())\n",
    "    print(f\"Close Price - ADF Statistic: {price_result[0]:.4f}\")\n",
    "    print(f\"Close Price - p-value: {price_result[1]:.4f}\")\n",
    "    \n",
    "    # Test on log returns\n",
    "    returns_result = adfuller(data['Log_Returns'].dropna())\n",
    "    print(f\"Log Returns - ADF Statistic: {returns_result[0]:.4f}\")\n",
    "    print(f\"Log Returns - p-value: {returns_result[1]:.4f}\")\n",
    "    \n",
    "    # Plot ACF and PACF\n",
    "    plt.figure(figsize=(14, 8))\n",
    "    \n",
    "    plt.subplot(2, 1, 1)\n",
    "    plot_acf(data['Log_Returns'].dropna(), ax=plt.gca(), lags=40)\n",
    "    plt.title('Autocorrelation Function (ACF) for Log Returns')\n",
    "    \n",
    "    plt.subplot(2, 1, 2)\n",
    "    plot_pacf(data['Log_Returns'].dropna(), ax=plt.gca(), lags=40)\n",
    "    plt.title('Partial Autocorrelation Function (PACF) for Log Returns')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Determine if log returns are stationary\n",
    "    is_stationary = returns_result[1] < 0.05\n",
    "    print(f\"\\nLog returns are {'stationary' if is_stationary else 'non-stationary'}\")\n",
    "    \n",
    "    return is_stationary\n",
    "\n",
    "def fit_distributions(returns):\n",
    "    \"\"\"\n",
    "    Fit various distributions to returns data and find the best fit\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    returns : Series\n",
    "        Log returns data\n",
    "    \n",
    "    Returns:\n",
    "    --------\n",
    "    best_dist : str\n",
    "        Name of the best fitting distribution\n",
    "    best_params : tuple\n",
    "        Parameters of the best fitting distribution\n",
    "    \"\"\"\n",
    "    print(\"\\n=== Distribution Fitting ===\")\n",
    "    \n",
    "    # Clean data\n",
    "    returns = returns.dropna()\n",
    "    \n",
    "    # Define distributions to try\n",
    "    distributions = [\n",
    "        ('Normal', stats.norm),\n",
    "        ('Student-t', stats.t),\n",
    "        ('Skewed-t', stats.skewnorm),\n",
    "        ('Generalized Error', stats.gennorm),\n",
    "        ('Laplace', stats.laplace)\n",
    "    ]\n",
    "    \n",
    "    # Fit distributions\n",
    "    results = []\n",
    "    \n",
    "    for name, dist in distributions:\n",
    "        # Fit distribution\n",
    "        params = dist.fit(returns)\n",
    "        \n",
    "        # Calculate log-likelihood\n",
    "        log_likelihood = np.sum(dist.logpdf(returns, *params))\n",
    "        \n",
    "        # Calculate AIC and BIC\n",
    "        k = len(params)\n",
    "        n\n",
    "            \n",
    "   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "927c13c7-25b9-48c3-8856-addaaec91e66",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:anaconda3]",
   "language": "python",
   "name": "conda-env-anaconda3-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
